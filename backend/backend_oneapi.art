/*
 * D = A * B + C
 *
 * Where:
 *
 * A:    (  -> K )
 *       (       )
 *       (| M    )
 *       (V      )
 *
 * B:    (  -> N )
 *       (       )
 *       (| K    )
 *       (V      )
 *
 * C, D: (  -> N )
 *       (       )
 *       (| M    )
 *       (V      )
 */

/*
layout:
RowMayor => 101,
ColMayor => 102,

transpose:
no_transpose => 111
transpose => 112
conj_transpose => 113
*/

#[import(cc="C", name="cblas_hgemm")]
fn cblas_hgemm (_layout : i32, _transpose_a : i32, _transpose_b: i32, _m : i64, _n : i64, _k : i64, _alpha : u16, _a : &mut [f16], _stride_a : i64, _b : &mut [f16], _stride_b : i64, _beta : u16, _c : &mut [f16], _stride_c : i64) -> ();

#[import(cc="C", name="cblas_sgemm")]
fn cblas_sgemm (_layout : i32, _transpose_a : i32, _transpose_b: i32, _m : i64, _n : i64, _k : i64, _alpha : f32, _a : &mut [f32], _stride_a : i64, _b : &mut [f32], _stride_b : i64, _beta : f32, _c : &mut [f32], _stride_c : i64) -> ();

#[import(cc="C", name="cblas_dgemm")]
fn cblas_dgemm (_layout : i32, _transpose_a : i32, _transpose_b: i32, _m : i64, _n : i64, _k : i64, _alpha : f64, _a : &mut [f64], _stride_a : i64, _b : &mut [f64], _stride_b : i64, _beta : f64, _c : &mut [f64], _stride_c : i64) -> ();


#[import(cc="C", name="MKL_malloc")]
fn mkl_malloc (_size: i64, _align: i32) -> &mut [i8];


fn matrix_multiply_oneapi_half (a : Tensor, b : Tensor, c : Tensor) -> () {
    let m = a.y_dim as i64;
    let n = b.x_dim as i64;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim as i64;

    cblas_hgemm(101, 111, 111, m, n, k, bitcast[u16](1 : f16), bitcast[&mut [f16]](a.data), a.stride as i64, bitcast[&mut [f16]](b.data), b.stride as i64, bitcast[u16](1 : f16), bitcast[&mut [f16]](c.data), c.stride as i64)
}

fn matrix_multiply_oneapi (a : Tensor_f32, b : Tensor_f32, c : Tensor_f32) -> () {
    let m = a.y_dim as i64;
    let n = b.x_dim as i64;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim as i64;

    cblas_sgemm(101, 111, 111, m, n, k, 1.0 : f32, bitcast[&mut [f32]](a.data), a.stride as i64, bitcast[&mut [f32]](b.data), b.stride as i64, 1.0 : f32, bitcast[&mut [f32]](c.data), c.stride as i64)
}

fn matrix_multiply_oneapi_double (a : Tensor_f64, b : Tensor_f64, c : Tensor_f64) -> () {
    let m = a.y_dim as i64;
    let n = b.x_dim as i64;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim as i64;

    cblas_dgemm(101, 111, 111, m, n, k, 1.0 : f64, bitcast[&mut [f64]](a.data), a.stride as i64, bitcast[&mut [f64]](b.data), b.stride as i64, 1.0 : f64, bitcast[&mut [f64]](c.data), c.stride as i64)
}
