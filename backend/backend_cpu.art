/*
 * D = A * B + C
 *
 * Where:
 *
 * A:    (  -> K )
 *       (       )
 *       (| M    )
 *       (V      )
 *
 * B:    (  -> N )
 *       (       )
 *       (| K    )
 *       (V      )
 *
 * C, D: (  -> N )
 *       (       )
 *       (| M    )
 *       (V      )
 */


struct print_function[T] { print : fn (T) -> () }
implicit = print_function[f16] { print = @| a | { print_f32(a as f32); } };
implicit = print_function[f32] { print = @| a | { print_f32(a); } };
implicit = print_function[f64] { print = @| a | { print_f64(a); } };

fn print_matrix[T] (t : Tensor[T], implicit print : print_function[T]) -> () {
    for y in range(0, t.y_dim) {
        for x in range(0, t.x_dim) {
            print.print(t.data(addr_tensor(x, y, t)));
            if (x < t.x_dim - 1) { print_string(", "); }
        }
        print_string("\n");
    }
}


fn matrix_multiply_naive (a : Tensor[a_element_type], b : Tensor[b_element_type], c : Tensor[c_element_type], r : Tensor[c_element_type]) -> () {
    let m = a.y_dim;
    let n = b.x_dim;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim;

    let print_progress = (m as i64 * n as i64 * k as i64) > (128 * 128 * 128);

    for y in range(0, m) {
        for x in range(0, n) {
            let mut rv = 0 : f32;

            for i in range(0, k) {
                let av = a.data(addr_tensor(i, y, a)) as f32;
                let bv = b.data(addr_tensor(x, i, b)) as f32;

                rv += av * bv;
            }

            let cv = c.data(addr_tensor(x, y, c)) as f32;

            r.data(addr_tensor(x, y, r)) = (cv + rv) as c_element_type;
        }
        if (print_progress) {
            print_string("\r");
            print_i32(y * 100 / m);
            print_string("%");
            print_flush();
        }
    }
    if (print_progress) {
        print_string("\r");
    }
}
