/*
 * D = A * B + C
 *
 * Where:
 *
 * A:    (  -> K )
 *       (       )
 *       (| M    )
 *       (V      )
 *
 * B:    (  -> N )
 *       (       )
 *       (| K    )
 *       (V      )
 *
 * C, D: (  -> N )
 *       (       )
 *       (| M    )
 *       (V      )
 */

// This should never changeâ„¢.
static warp_size = 32;
static device_mp_count = 20; //TODO: Turn that into an intrinsic or something?


fn @nvvm_wmma_expand (a_fragment : (simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2]),
        b_fragment : (simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2]),
        c_fragment : (simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2]),
        a_mode : AddrMode,
        b_mode : AddrMode,
        ) {
    let (a1, a2, a3, a4, a5, a6, a7, a8) = a_fragment;
    let (b1, b2, b3, b4, b5, b6, b7, b8) = b_fragment;
    let (c1, c2, c3, c4) = c_fragment;

    match (a_mode, b_mode) {
        (AddrMode::RowMayor, AddrMode::RowMayor) =>
            nvvm_wmma_row_row(a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4, b5, b6, b7, b8, c1, c2, c3, c4),
        (AddrMode::ColMayor, AddrMode::RowMayor) =>
            nvvm_wmma_col_row(a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4, b5, b6, b7, b8, c1, c2, c3, c4),
        (AddrMode::RowMayor, AddrMode::ColMayor) =>
            nvvm_wmma_row_col(a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4, b5, b6, b7, b8, c1, c2, c3, c4),
        (AddrMode::ColMayor, AddrMode::ColMayor) =>
            nvvm_wmma_col_col(a1, a2, a3, a4, a5, a6, a7, a8, b1, b2, b3, b4, b5, b6, b7, b8, c1, c2, c3, c4)
    }
}

fn @nvvm_wmma_load_a_expand(fragment_tensor : Tensor) {
    let cuda_data = bitcast[&i8](fragment_tensor.data);

    match fragment_tensor.addr_mode {
        AddrMode::RowMayor =>
            if (fragment_tensor.stride > 16) {
                nvvm_wmma_load_a_row_stride(cuda_data, fragment_tensor.stride)
            } else {
                nvvm_wmma_load_a_row(cuda_data)
            },
        AddrMode::ColMayor =>
            if (fragment_tensor.stride > 16) {
                nvvm_wmma_load_a_col_stride(cuda_data, fragment_tensor.stride)
            } else {
                nvvm_wmma_load_a_col(cuda_data)
            }
    }
}

fn @nvvm_wmma_load_b_expand(fragment_tensor : Tensor) {
    let cuda_data = bitcast[&i8](fragment_tensor.data);

    match fragment_tensor.addr_mode {
        AddrMode::RowMayor =>
            if (fragment_tensor.stride > 16) {
                nvvm_wmma_load_b_row_stride(cuda_data, fragment_tensor.stride)
            } else {
                nvvm_wmma_load_b_row(cuda_data)
            },
        AddrMode::ColMayor =>
            if (fragment_tensor.stride > 16) {
                nvvm_wmma_load_b_col_stride(cuda_data, fragment_tensor.stride)
            } else {
                nvvm_wmma_load_b_col(cuda_data)
            }
    }
}

fn @nvvm_wmma_load_c_expand(fragment_tensor : Tensor) {
    let cuda_data = bitcast[&i8](fragment_tensor.data);

    match fragment_tensor.addr_mode {
        AddrMode::RowMayor =>
            if (fragment_tensor.stride > 16) {
                nvvm_wmma_load_c_row_stride(cuda_data, fragment_tensor.stride)
            } else {
                nvvm_wmma_load_c_row(cuda_data)
            },
        AddrMode::ColMayor =>
            if (fragment_tensor.stride > 16) {
                nvvm_wmma_load_c_col_stride(cuda_data, fragment_tensor.stride)
            } else {
                nvvm_wmma_load_c_col(cuda_data)
            }
    }
}

fn @nvvm_wmma_store_d_expand (d_fragment_tensor : Tensor, acc_fragment : (simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2])) {
    let d_cuda = bitcast[&mut i8](d_fragment_tensor.data);
    let (acc1, acc2, acc3, acc4) = acc_fragment;

    match d_fragment_tensor.addr_mode {
        AddrMode::RowMayor =>
            if (d_fragment_tensor.stride > 16) {
                nvvm_wmma_store_d_row_stride(d_cuda, acc1, acc2, acc3, acc4, d_fragment_tensor.stride)
            } else {
                nvvm_wmma_store_d_row(d_cuda, acc1, acc2, acc3, acc4)
            },
        AddrMode::ColMayor =>
            if (d_fragment_tensor.stride > 16) {
                nvvm_wmma_store_d_col_stride(d_cuda, acc1, acc2, acc3, acc4, d_fragment_tensor.stride)
            } else {
                nvvm_wmma_store_d_col(d_cuda, acc1, acc2, acc3, acc4)
            }
    }
}

fn matrix_multiply_nvvm_blocked_noshm (nvvm : Accelerator, a : Tensor, b : Tensor, c : Tensor, d : Tensor) -> () {
    let m = a.y_dim;
    let n = b.x_dim;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim;

    //Each warp will be used to calcuate this geometry of tiles.
    let tile_size_x = 16;
    let tile_size_y = 16;
    let tile_size_k = 16;

    let warp_x_tiles = 2;
    let warp_y_tiles = 4;

    let block_x_warps = 4;
    let block_y_warps = 2;


    let block_x_tiles = block_x_warps * warp_x_tiles;
    let block_y_tiles = block_y_warps * warp_y_tiles;

    let block_size_x = block_x_tiles * tile_size_x;
    let block_size_y = block_y_tiles * tile_size_y;

    let warp_size_x = warp_x_tiles * tile_size_x;
    let warp_size_y = warp_y_tiles * tile_size_y;

    //Total matrix geometry
    let matrix_x_tiles = n / tile_size_x;
    let matrix_y_tiles = m / tile_size_y;

    let matrix_x_blocks = matrix_x_tiles / block_x_tiles;
    let matrix_y_blocks = matrix_y_tiles / block_y_tiles;

    let matrix_total_blocks = matrix_x_blocks * matrix_y_blocks;
    let block_total_warps = block_x_warps * block_y_warps;
    let threads_per_block = block_total_warps * warp_size;

    let parallel_blocks = device_mp_count;

    print_string("execute blocked ");
    print_string("(");
    print_i32(matrix_x_tiles);
    print_string(", ");
    print_i32(matrix_y_tiles);
    print_string(") (");
    print_i32(matrix_x_blocks);
    print_string(", ");
    print_i32(matrix_y_blocks);
    print_string(") (");
    print_i32(parallel_blocks);
    print_string(", ");
    print_i32(threads_per_block);
    print_string(")\n");

    for work_item in nvvm.exec((parallel_blocks * threads_per_block, 1, 1), (threads_per_block, 1, 1)) {
        let warp_id = work_item.tidx() / warp_size;
        //let lane_id = work_item.tidx() % warp_size;

        for block_index in range_step(work_item.bidx(), matrix_total_blocks, parallel_blocks) {
            let block_x = (block_index % matrix_x_blocks) * block_size_x;
            let block_y = (block_index / matrix_x_blocks) * block_size_y;

            let warp_x = block_x + (warp_id % block_x_warps) * warp_size_x;
            let warp_y = block_y + (warp_id / block_x_warps) * warp_size_y;

            //TODO: this depends on the current layout!
            let mut acc_fragments : [[(simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2]) * 4 /* warp_y_tiles */] * 2 /* warp_x_tiles */];

            /* Load C fragments into registers */
            for tile_x in range(0, warp_x_tiles) {
                for tile_y in range(0, warp_y_tiles) {
                    let local_x = tile_x * tile_size_x;
                    let local_y = tile_y * tile_size_y;

                    let global_x = warp_x + local_x;
                    let global_y = warp_y + local_y;

                    let c_fragment_tensor = sub_tensor(c, global_x, global_y, tile_size_x, tile_size_y);
                    let c_fragment = nvvm_wmma_load_c_expand(c_fragment_tensor);

                    acc_fragments(tile_x)(tile_y) = c_fragment;
                }
            }

            for global_k in range_step(0, k, tile_size_k) {
                let mut a_fragments : [(simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2]) * 4 /* warp_y_tiles */];

                for tile_x in unroll(0, warp_x_tiles /* 2 */) {
                    let local_x = tile_x * tile_size_x;
                    let global_x = warp_x + local_x;

                    let b_fragment_tensor = sub_tensor(b, global_x, global_k, tile_size_x, tile_size_k);
                    let b_fragment = nvvm_wmma_load_b_expand(b_fragment_tensor);

                    for tile_y in unroll(0, warp_y_tiles /* 4 */) {
                        let local_y = tile_y * tile_size_y;
                        let global_y = warp_y + local_y;

                        let acc_fragment = acc_fragments(tile_x)(tile_y);

                        let a_fragment_tensor = sub_tensor(a, global_k, global_y, tile_size_k, tile_size_y);
                        let a_fragment = if (tile_x == 0) {
                            let a_fragment = nvvm_wmma_load_a_expand(a_fragment_tensor);
                            a_fragments(tile_y) = a_fragment;
                            a_fragment
                        } else {
                            a_fragments(tile_y)
                        };

                        let result_fragment = nvvm_wmma_expand (a_fragment, b_fragment, acc_fragment, a_fragment_tensor.addr_mode, b_fragment_tensor.addr_mode);

                        acc_fragments(tile_x)(tile_y) = result_fragment;
                    }
                }
            }

            for tile_x in range(0, warp_x_tiles) {
                for tile_y in range(0, warp_y_tiles) {
                    let local_x = tile_x * tile_size_x;
                    let local_y = tile_y * tile_size_y;

                    let global_x = warp_x + local_x;
                    let global_y = warp_y + local_y;

                    let result_fragment = acc_fragments(tile_x)(tile_y);

                    let d_fragment_tensor = sub_tensor(d, global_x, global_y, tile_size_x, tile_size_y);

                    nvvm_wmma_store_d_expand (d_fragment_tensor, result_fragment)
                }
            }
        }
    }
}

fn matrix_multiply_nvvm_blocked (nvvm : Accelerator, a : Tensor, b : Tensor, c : Tensor, d : Tensor) -> () {
    let m = a.y_dim;
    let n = b.x_dim;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim;

    //Each warp will be used to calcuate this geometry of tiles.
    let tile_size_x = 16;
    let tile_size_y = 16;
    let tile_size_k = 16;

    let warp_x_tiles = 2;
    let warp_y_tiles = 4;

    let block_x_warps = 4;
    let block_y_warps = 2;


    let block_x_tiles = block_x_warps * warp_x_tiles;
    let block_y_tiles = block_y_warps * warp_y_tiles;

    let block_size_x = block_x_tiles * tile_size_x;
    let block_size_y = block_y_tiles * tile_size_y;

    let warp_size_x = warp_x_tiles * tile_size_x;
    let warp_size_y = warp_y_tiles * tile_size_y;

    //Total matrix geometry
    let matrix_x_tiles = n / tile_size_x;
    let matrix_y_tiles = m / tile_size_y;

    let matrix_x_blocks = matrix_x_tiles / block_x_tiles;
    let matrix_y_blocks = matrix_y_tiles / block_y_tiles;

    let matrix_total_blocks = matrix_x_blocks * matrix_y_blocks;
    let block_total_warps = block_x_warps * block_y_warps;
    let threads_per_block = block_total_warps * warp_size;

    let parallel_blocks = device_mp_count;

    print_string("execute blocked ");
    print_string("tiles (");
    print_i32(warp_x_tiles);
    print_string(", ");
    print_i32(warp_y_tiles);
    print_string(") blocks (");
    print_i32(matrix_x_blocks);
    print_string(", ");
    print_i32(matrix_y_blocks);
    print_string(") launch (");
    print_i32(parallel_blocks);
    print_string(", ");
    print_i32(threads_per_block);
    print_string(")\n");

    let k_shared_tiles = 4;
    let shared_memory_size = tile_size_k * k_shared_tiles * block_size_y * 2; //TODO: add skew_half in an appropriate place
                                                                              //TODO: *2 is not correct, calculate second part based on block_size_x

    for work_item in nvvm.exec((parallel_blocks * threads_per_block, 1, 1), (threads_per_block, 1, 1)) {
        let shared_memory = bitcast[&mut [f16]](reserve_shared[f16](shared_memory_size));

        let a_shared_tensor = Tensor {
            data = shared_memory,
            x_dim = tile_size_k * k_shared_tiles,
            y_dim = block_size_y,
            addr_mode = AddrMode::RowMayor,
            stride = tile_size_k * k_shared_tiles
        };
        let b_shared_tensor = Tensor {
            data = bitcast[&mut[f16]](&shared_memory(tile_size_k * k_shared_tiles * block_size_y)), //TODO: calculate this offset elsewhere
            x_dim = block_size_x,
            y_dim = tile_size_k * k_shared_tiles,
            addr_mode = AddrMode::RowMayor,
            stride = block_size_x
        };

        let warp_id = work_item.tidx() / warp_size;
        let lane_id = work_item.tidx() % warp_size;

        for block_index in range_step(work_item.bidx(), matrix_total_blocks, parallel_blocks) {
            let block_x = (block_index % matrix_x_blocks) * block_size_x;
            let block_y = (block_index / matrix_x_blocks) * block_size_y;

            let warp_x = block_x + (warp_id % block_x_warps) * warp_size_x;
            let warp_y = block_y + (warp_id / block_x_warps) * warp_size_y;

            //TODO: this depends on the current layout!
            let mut acc_fragments : [[(simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2]) * 4 /* warp_y_tiles */] * 2 /* warp_x_tiles */];

            /* Load C fragments into registers */
            for tile_x in range(0, warp_x_tiles) {
                for tile_y in range(0, warp_y_tiles) {
                    let local_x = tile_x * tile_size_x;
                    let local_y = tile_y * tile_size_y;

                    let global_x = warp_x + local_x;
                    let global_y = warp_y + local_y;

                    let c_fragment_tensor = sub_tensor(c, global_x, global_y, tile_size_x, tile_size_y);
                    let c_fragment = nvvm_wmma_load_c_expand(c_fragment_tensor);

                    acc_fragments(tile_x)(tile_y) = c_fragment;
                }
            }

            for global_k_sliced in range_step(0, k, tile_size_k * k_shared_tiles) {
                //Populate shared tensors
                if (warp_id < 4) { //tid 0 - 127
                    for local_k in range(0, k_shared_tiles * tile_size_k) { //TODO: this relies on the specific size of the block, and probably on the block geometry.
                        let local_y = work_item.tidx();

                        let global_k = global_k_sliced + local_k;
                        let global_y = block_y + local_y;

                        let data = a.data(addr_tensor(global_k, global_y, a));
                        a_shared_tensor.data(addr_tensor(local_k, local_y, a_shared_tensor)) = data;
                    }
                } else { //tid 128 - 255
                    for local_k in range(0, k_shared_tiles * tile_size_k) { //TODO: this relies on the specific size of the block, and probably on the block geometry.
                        let local_x = work_item.tidx() - 128;

                        let global_k = global_k_sliced + local_k;
                        let global_x = block_x + local_x;

                        let data = b.data(addr_tensor(global_x, global_k, b));
                        b_shared_tensor.data(addr_tensor(local_x, local_k, b_shared_tensor)) = data;
                    }
                }

                nvvm.barrier();

                for local_k_tile in range(0, k_shared_tiles) {
                    let local_k = local_k_tile * tile_size_k;
                    let global_k = global_k_sliced + local_k;

                    let mut a_fragments : [(simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2]) * 4 /* warp_y_tiles */];

                    for tile_x in unroll(0, warp_x_tiles /* 2 */) {
                        let local_x = tile_x * tile_size_x;
                        let global_x = warp_x + local_x;

                        let in_block_x = global_x - block_x;

                        let b_fragment_tensor = sub_tensor(b_shared_tensor, in_block_x, local_k, tile_size_x, tile_size_k);
                        let b_fragment = nvvm_wmma_load_b_expand(b_fragment_tensor);

                        for tile_y in unroll(0, warp_y_tiles /* 4 */) {
                            let local_y = tile_y * tile_size_y;
                            let global_y = warp_y + local_y;

                            let in_block_y  = global_y - block_y;

                            let acc_fragment = acc_fragments(tile_x)(tile_y);

                            let a_fragment_tensor = sub_tensor(a_shared_tensor, local_k, in_block_y, tile_size_k, tile_size_y);
                            let a_fragment = if (tile_x == 0) {
                                let a_fragment = nvvm_wmma_load_a_expand(a_fragment_tensor);
                                a_fragments(tile_y) = a_fragment;
                                a_fragment
                            } else {
                                a_fragments(tile_y)
                            };

                            let result_fragment = nvvm_wmma_expand (a_fragment, b_fragment, acc_fragment, a_fragment_tensor.addr_mode, b_fragment_tensor.addr_mode);

                            acc_fragments(tile_x)(tile_y) = result_fragment;
                        }
                    }
                }

                nvvm.barrier();
            }

            for tile_x in range(0, warp_x_tiles) {
                for tile_y in range(0, warp_y_tiles) {
                    let local_x = tile_x * tile_size_x;
                    let local_y = tile_y * tile_size_y;

                    let global_x = warp_x + local_x;
                    let global_y = warp_y + local_y;

                    let result_fragment = acc_fragments(tile_x)(tile_y);

                    let d_fragment_tensor = sub_tensor(d, global_x, global_y, tile_size_x, tile_size_y);

                    nvvm_wmma_store_d_expand (d_fragment_tensor, result_fragment)
                }
            }
        }
    }
}

fn matrix_multiply_nvvm_tiled (nvvm : Accelerator, a : Tensor, b : Tensor, c : Tensor, d : Tensor) -> () {
    let m = a.y_dim;
    let n = b.x_dim;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim;

    let tile_size_x = 16;
    let tile_size_y = 16;
    let tile_size_k = 16;

    //Each block will calculated x * y many tiles.
    let block_tiles_x = 8;
    let block_tiles_y = 8;

    //Each warp will be used to calcuate this geometry of tiles.
    let warp_x_tiles = 2;
    let warp_y_tiles = 4;

    //Each block consists of this many warps.
    let x_warps_per_block = block_tiles_x / warp_x_tiles;
    let y_warps_per_block = block_tiles_y / warp_y_tiles;

    let num_x_warps = n / tile_size_x / warp_x_tiles;
    let num_y_warps = m / tile_size_y / warp_y_tiles;

    let matrix_x_blocks = num_x_warps / x_warps_per_block;
    let matrix_y_blocks = num_y_warps / y_warps_per_block;

    let block_x_threads = x_warps_per_block * warp_size;
    let block_y_threads = y_warps_per_block;

    let x_threads = matrix_x_blocks * block_x_threads;
    let y_threads = matrix_y_blocks * block_y_threads;

    print_string("tiled configuration: (");
    print_i32(x_threads);
    print_string(", ");
    print_i32(y_threads);
    print_string(") block size (");
    print_i32(block_x_threads);
    print_string(", ");
    print_i32(block_y_threads);
    print_string(")\n");

    for work_item in nvvm.exec((x_threads, y_threads,  1), (block_x_threads, block_y_threads, 1)) {
        let warp_x = work_item.gidx() / warp_size * warp_x_tiles * tile_size_x;
        let warp_y = work_item.gidy() * warp_y_tiles * tile_size_y;

        //TODO: this depends on the current layout!
        let mut acc_fragments : [[(simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2]) * 4] * 2];

        /* Load C fragments into registers */
        for tile_x in range(0, warp_x_tiles) {
            for tile_y in range(0, warp_y_tiles) {
                let local_x = tile_x * tile_size_x;
                let local_y = tile_y * tile_size_y;

                let global_x = warp_x + local_x;
                let global_y = warp_y + local_y;

                let c_fragment_tensor = sub_tensor(c, global_x, global_y, tile_size_x, tile_size_y);
                let c_fragment = nvvm_wmma_load_c_expand(c_fragment_tensor);

                acc_fragments(tile_x)(tile_y) = c_fragment;
            }
        }

        for global_k in range_step(0, k, tile_size_k) {
            let mut a_fragments : [(simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2], simd[f16 * 2]) * 4];

            for tile_x in unroll(0, warp_x_tiles /* = 2 */) {
                let local_x = tile_x * tile_size_x;
                let global_x = warp_x + local_x;

                let b_fragment_tensor = sub_tensor(b, global_x, global_k, tile_size_x, tile_size_k);
                let b_fragment = nvvm_wmma_load_b_expand(b_fragment_tensor);

                for tile_y in unroll(0, warp_y_tiles /* = 4 */) {
                    let local_y = tile_y * tile_size_y;
                    let global_y = warp_y + local_y;

                    let acc_fragment = acc_fragments(tile_x)(tile_y);

                    let a_fragment_tensor = sub_tensor(a, global_k, global_y, tile_size_k, tile_size_y);
                    let a_fragment = if (tile_x == 0) {
                        let a_fragment = nvvm_wmma_load_a_expand(a_fragment_tensor);
                        a_fragments(tile_y) = a_fragment;
                        a_fragment
                    } else {
                        a_fragments(tile_y)
                    };

                    let result_fragment = nvvm_wmma_expand (a_fragment, b_fragment, acc_fragment, a_fragment_tensor.addr_mode, b_fragment_tensor.addr_mode);

                    acc_fragments(tile_x)(tile_y) = result_fragment;
                }
            }
        }

        for tile_x in range(0, warp_x_tiles) {
            for tile_y in range(0, warp_y_tiles) {
                let local_x = tile_x * tile_size_x;
                let local_y = tile_y * tile_size_y;

                let global_x = warp_x + local_x;
                let global_y = warp_y + local_y;

                let result_fragment = acc_fragments(tile_x)(tile_y);

                let d_fragment_tensor = sub_tensor(d, global_x, global_y, tile_size_x, tile_size_y);

                nvvm_wmma_store_d_expand (d_fragment_tensor, result_fragment)
            }
        }
    }
}


fn matrix_multiply_nvvm (nvvm : Accelerator, a : Tensor, b : Tensor, c : Tensor, d : Tensor) -> () {
    let m = a.y_dim;
    let n = b.x_dim;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim;

    let tile_size_x = 16;
    let tile_size_y = 16;
    let tile_size_k = 16;

    let block_factor_x = select(n % (tile_size_x * 2) != 0, 1, select(n % (tile_size_x * 4) != 0, 2, 4));
    let block_factor_y = select(m % (tile_size_y * 2) != 0, 1, select(m % (tile_size_y * 4) != 0, 2, 4));

    let x_threads = n * warp_size / tile_size_x;
    let y_threads = m / tile_size_y;

    let block_x_threads = warp_size * block_factor_x;
    let block_y_threads = block_factor_y;

    print_string("simple configuration: (");
    print_i32(x_threads);
    print_string(", ");
    print_i32(y_threads);
    print_string(") block size (");
    print_i32(block_x_threads);
    print_string(", ");
    print_i32(block_y_threads);
    print_string(")\n");

    for work_item in nvvm.exec((x_threads, y_threads,  1), (block_x_threads, block_y_threads, 1)) {
        let tile_x = work_item.gidx() / warp_size * tile_size_x;
        let tile_y = work_item.gidy() * tile_size_y;

        let c_fragment_tensor = sub_tensor(c, tile_x, tile_y, tile_size_x, tile_size_y);
        let mut acc_fragment = nvvm_wmma_load_c_expand(c_fragment_tensor);

        for global_k in range_step(0, k, tile_size_k) {
            let a_fragment_tensor = sub_tensor(a, global_k, tile_y, tile_size_k, tile_size_y);
            let b_fragment_tensor = sub_tensor(b, tile_x, global_k, tile_size_x, tile_size_k);

            let a_fragment = nvvm_wmma_load_a_expand(a_fragment_tensor);
            let b_fragment = nvvm_wmma_load_b_expand(b_fragment_tensor);

            acc_fragment = nvvm_wmma_expand (a_fragment, b_fragment, acc_fragment, a_fragment_tensor.addr_mode, b_fragment_tensor.addr_mode);
        }

        let d_fragment_tensor = sub_tensor(d, tile_x, tile_y, tile_size_x, tile_size_y);
        nvvm_wmma_store_d_expand (d_fragment_tensor, acc_fragment)
    }
}

fn matrix_multiply_nvvm_simple (nvvm : Accelerator, a : Tensor, b : Tensor, c : Tensor, d : Tensor) -> () {
    let m = a.y_dim;
    let n = b.x_dim;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim;

    print_string("nvvm ref implementation\n");

    for work_item in nvvm.exec((n, m,  1), (32, 16, 1)) {
        let x = work_item.gidx();
        let y = work_item.gidy();

        let mut rv = c.data(addr_tensor(x, y, c)) as f32;

        for i in range(0, k) {
            let av = a.data(addr_tensor(i, y, a)) as f32;
            let bv = b.data(addr_tensor(x, i, b)) as f32;

            rv += av * bv;
        }

        d.data(addr_tensor(x, y, d)) = rv as f16;
    }
}

fn matrix_multiply_nvvm_simple_shared (nvvm : Accelerator, a : Tensor, b : Tensor, c : Tensor, d : Tensor) -> () {
    let m = a.y_dim;
    let n = b.x_dim;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim;

    print_string("nvvm ref implementation\n");

    for work_item in nvvm.exec((n, m,  1), (32, 32, 1)) {
        let mut rv = c.data(addr_tensor(work_item.gidx(), work_item.gidy(), c)) as f32;
        //let mut rv = 0 as f32;

        for batch in range_step(0, k, 32) {
            let As_data = bitcast[&mut [f32]](reserve_shared[f32](32 * 32));
            let Bs_data = bitcast[&mut [f32]](reserve_shared[f32](32 * 32));

            let A_shared = Tensor_f32 { data = As_data, x_dim = 32, y_dim = 32, addr_mode = AddrMode::RowMayor, stride = 32 };
            let B_shared = Tensor_f32 { data = Bs_data, x_dim = 32, y_dim = 32, addr_mode = AddrMode::RowMayor, stride = 32 };

            let a_local = a.data(addr_tensor(batch + work_item.tidx(), work_item.gidy(), a));
            A_shared.data(addr_tensor_f32(work_item.tidx(), work_item.tidy(), A_shared)) = a_local as f32;

            let b_local = b.data(addr_tensor(work_item.gidx(), batch + work_item.tidy(), b));
            B_shared.data(addr_tensor_f32(work_item.tidx(), work_item.tidy(), B_shared)) = b_local as f32;

            nvvm.barrier();

            for index in unroll(0, 32) {
                let av = A_shared.data(addr_tensor_f32(index, work_item.tidy(), A_shared));
                let bv = B_shared.data(addr_tensor_f32(work_item.tidx(), index, B_shared));

                rv += av * bv;
            }

            nvvm.barrier();
        }

        d.data(addr_tensor(work_item.gidx(), work_item.gidy(), d)) = rv as f16;
    }
}

fn matrix_multiply_nvvm_simple_shared_f32 (nvvm : Accelerator, a : Tensor_f32, b : Tensor_f32, c : Tensor_f32, d : Tensor_f32) -> () {
    let m = a.y_dim;
    let n = b.x_dim;
    //assert(a.x_dim == b.y_dim);
    let k = a.x_dim;

    print_string("nvvm ref implementation\n");

    for work_item in nvvm.exec((n, m,  1), (32, 32, 1)) {
        let mut rv = c.data(addr_tensor_f32(work_item.gidx(), work_item.gidy(), c));
        //let mut rv = 0 : f32;

        for batch in range_step(0, k, 32) {
            let As_data = bitcast[&mut [f32]](reserve_shared[f32](32 * 32));
            let Bs_data = bitcast[&mut [f32]](reserve_shared[f32](32 * 32));

            let A_shared = Tensor_f32 { data = As_data, x_dim = 32, y_dim = 32, addr_mode = AddrMode::RowMayor, stride = 32 };
            let B_shared = Tensor_f32 { data = Bs_data, x_dim = 32, y_dim = 32, addr_mode = AddrMode::RowMayor, stride = 32 };

            let a_local = a.data(addr_tensor_f32(batch + work_item.tidx(), work_item.gidy(), a));
            A_shared.data(addr_tensor_f32(work_item.tidx(), work_item.tidy(), A_shared)) = a_local;

            let b_local = b.data(addr_tensor_f32(work_item.gidx(), batch + work_item.tidy(), b));
            B_shared.data(addr_tensor_f32(work_item.tidx(), work_item.tidy(), B_shared)) = b_local;

            nvvm.barrier();

            for index in unroll(0, 32) {
                let av = A_shared.data(addr_tensor_f32(index, work_item.tidy(), A_shared));
                let bv = B_shared.data(addr_tensor_f32(work_item.tidx(), index, B_shared));

                rv += av * bv;
            }

            nvvm.barrier();
        }

        d.data(addr_tensor_f32(work_item.gidx(), work_item.gidy(), d)) = rv;
    }
}

fn matrix_multiply_nvvm_copy (nvvm : Accelerator, at : Tensor_f32, bt : Tensor_f32, ct : Tensor_f32, dt : Tensor_f32) -> () {
    let m = at.y_dim;
    let n = bt.x_dim;
    //assert(a.x_dim == b.y_dim);
    let k = at.x_dim;

    print_string("nvvm ref implementation\n");

    let wA = 4096;
    let wB = 4096;

    let BLOCK_SIZE = 32;

    for work_item in nvvm.exec((n, m,  1), (32, 32, 1)) {

  // Block index
  let bx = work_item.bidx();
  let by = work_item.bidy();

  // Thread index
  let tx = work_item.tidx();
  let ty = work_item.tidy();

  // Index of the first sub-matrix of A processed by the block
  let aBegin = wA * BLOCK_SIZE * by;

  // Index of the last sub-matrix of A processed by the block
  let aEnd   = aBegin + wA - 1;

  // Step size used to iterate through the sub-matrices of A
  let aStep  = BLOCK_SIZE;

  // Index of the first sub-matrix of B processed by the block
  let bBegin = BLOCK_SIZE * bx;

  // Step size used to iterate through the sub-matrices of B
  let bStep  = BLOCK_SIZE * wB;

  // Csub is used to store the element of the block sub-matrix
  // that is computed by the thread
  let c = wB * BLOCK_SIZE * by + BLOCK_SIZE * bx;
  let mut Csub = ct.data(c + wB * ty + tx);


  //for (int a = aBegin, b = bBegin;
  //     a <= aEnd;
  //     a += aStep, b += bStep)
  let mut b = bBegin;
  for a in range_step(aBegin, aEnd, aStep) {
    // Declaration of the shared memory array As used to
    // store the sub-matrix of A
    //__shared__ float As[BLOCK_SIZE][BLOCK_SIZE];
            let As_data = bitcast[&mut [f32]](reserve_shared[f32](BLOCK_SIZE * BLOCK_SIZE));
            let A_shared = Tensor_f32 { data = As_data, x_dim = 32, y_dim = 32, addr_mode = AddrMode::RowMayor, stride = 32 };

    // Declaration of the shared memory array Bs used to
    // store the sub-matrix of B
    //__shared__ float Bs[BLOCK_SIZE][BLOCK_SIZE];
            let Bs_data = bitcast[&mut [f32]](reserve_shared[f32](BLOCK_SIZE * BLOCK_SIZE));
            let B_shared = Tensor_f32 { data = Bs_data, x_dim = 32, y_dim = 32, addr_mode = AddrMode::RowMayor, stride = 32 };

    // Load the matrices from device memory
    // to shared memory; each thread loads
    // one element of each matrix
    //As[ty][tx] = A[a + wA * ty + tx];
            A_shared.data(addr_tensor_f32(tx, ty, A_shared)) = at.data(a + wA * ty + tx);
    //Bs[ty][tx] = B[b + wB * ty + tx];
            B_shared.data(addr_tensor_f32(tx, ty, B_shared)) = bt.data(b + wB * ty + tx);

    // Synchronize to make sure the matrices are loaded
            nvvm.barrier();

    // Multiply the two matrices together;
    // each thread computes one element
    // of the block sub-matrix
//#pragma unroll
    //for (int k = 0; k < BLOCK_SIZE; ++k)
    for k in unroll(0, BLOCK_SIZE) {
            let a_data = A_shared.data(addr_tensor_f32(k, ty, A_shared));
            let b_data = B_shared.data(addr_tensor_f32(tx, k, B_shared));

            Csub += a_data * b_data;
    }

    // Synchronize to make sure that the preceding
    // computation is done before loading two new
    // sub-matrices of A and B in the next iteration
            nvvm.barrier();

    b += bStep;
  }


  dt.data(c + wB * ty + tx) = Csub;

    }
}
